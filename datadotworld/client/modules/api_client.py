# coding: utf-8
"""
    data.world API

    data.world is designed for data and the people who work with data.  From professional projects to open data, data.world helps you host and share your data, collaborate with your team, and capture context and conclusions as you work.   Using this API users are able to easily access data and manage their data projects regardless of language or tool of preference.  Check out our [documentation](https://dwapi.apidocs.io) for tips on how to get started, tutorials and to interact with the API right within your browser.

    OpenAPI spec version: 0.14.1
    Contact: help@data.world
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import os
import re
import json
import mimetypes
import tempfile
import threading
import backoff

from datetime import date, datetime
from requests.adapters import BaseAdapter


# python 2 and python 3 compatibility library
from six import PY3, integer_types, iteritems, text_type
from six.moves.urllib.parse import quote

class ApiClient(object):
    def __init__(self, api_token, **kwargs):
        """Simple client for data.world API
        :param api_token: API Authorization Token
        :type api_token: str
        """

        # The following properties can be overwritten for testing/tuning
        self._api_url = kwargs.get('api_url', 'https://api.data.world/v0')
        self._conn_timeout = kwargs.get('connect_timeout', 3.05)
        self._read_timeout = kwargs.get('read_timeout', 600)
        self._max_threads = kwargs.get('max_threads', 10)
        self._api_token = api_token
        self.default_headers = {
            'Accept': 'application/json',
            'Authorization': 'Bearer {}'.format(self._api_token),
            'Content-Type': 'application/json',
            'User-Agent': 'data.world-py'
        }

    def connection_check(self):
        """Verify network connectivity
        Ensures that the client can communicate with data.world's API
        """
        with metrics.http_request_timer('user'):
            try:
                self._session.get(
                    '{}/user'.format(self._api_url),
                    timeout=(self._conn_timeout, self._read_timeout)
                ).raise_for_status()
            except RequestException as e:
                raise convert_requests_exception(e)

    def append_stream(self, owner, dataset, stream, records):
        """Append records to a stream in a data.world dataset
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param stream: Stream ID
        :type stream: str
        :param records: Objects to be appended to the stream
        :type records: iterable
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('append') as t:
            t.tags['stream'] = stream

            try:
                self._session.post(
                    '{}/streams/{}/{}/{}'.format(
                        self._api_url, owner, dataset, stream),
                    data=to_jsonlines(records).encode('utf-8'),
                    headers={'Content-Type':
                             'application/json-l; charset=utf-8'}
                ).raise_for_status()
            except RequestException as e:
                raise convert_requests_exception(e)

        """Asynchronously append records to a stream in a data.world dataset
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param stream: Stream ID
        :type stream: str
        :param queue: Queue with objects to be appended to the stream
        :type queue: asyncio.Queue
        :param chunk_size: Chunk or batch size
        :type chunk_size: int
        :raises ApiError: Failure invoking data.world API
        """

    def create_dataset(self, owner, dataset, **kwargs):
        """Create a new dataset
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param kwargs: Dataset properties
        :type kwargs: dict
        :returns: Response object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        .. seealso:: `Dataset properties
            <https://apidocs.data.world/v0/models/datasetcreaterequest>`_
        """
        with metrics.http_request_timer('create_dataset'):
            try:
                resp = self._session.put(
                    '{}/datasets/{}/{}'.format(self._api_url, owner, dataset),
                    json=kwargs,
                    timeout=(self._conn_timeout, self._read_timeout)
                )
                resp.raise_for_status()
                return resp.json()
            except RequestException as e:
                raise convert_requests_exception(e)

    def get_dataset(self, owner, dataset):
        """Fetch dataset info
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :returns: Dataset object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('dataset'):
            try:
                resp = self._session.get(
                    '{}/datasets/{}/{}'.format(self._api_url, owner, dataset),
                    timeout=(self._conn_timeout, self._read_timeout)
                )
                resp.raise_for_status()
                return resp.json()
            except RequestException as e:
                raise convert_requests_exception(e)

    def get_current_version(self, owner, dataset, stream):
        """Returns version of a sample record from a given stream
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param stream: Stream ID
        :type stream: str
        :returns: Response object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('fetch_latest_version'):
            try:
                resp = self._session.get(
                    '{}/sql/{}/{}'.format(self._api_url, owner, dataset),
                    params={
                        'query': 'SELECT * '
                                 'FROM `{}`.`{}`.`{}` '
                                 'LIMIT 1'.format(
                                     owner, dataset, to_table_name(stream))},
                    timeout=(self._conn_timeout, self._read_timeout))
                resp.raise_for_status()
                rows = resp.json()
                return (None if len(rows) == 0
                        else rows[0].get('singer_version'))
            except RequestException as e:
                if e.response.status_code == 400:
                    logger.warn('Unable fetch latest version. '
                                'Expected if table doesn\'t exist yet. '
                                'Server message: {}'.format(e.response.text))
                    return None
                raise convert_requests_exception(e)

    def set_stream_schema(self, owner, dataset, stream, **kwargs):
        """Sets schema of a stream in a data.world dataset
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param stream: Stream ID
        :type stream: str
        :param kwargs: Schema properties (primaryKeyFields, sequenceField,
        updateMethod)
        :type kwargs: dict
        :returns: Response object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('set_stream_schema'):
            try:
                resp = self._session.patch(
                    '{}/streams/{}/{}/{}/schema'.format(self._api_url, owner,
                                                        dataset, stream),
                    json=kwargs,
                    timeout=(self._conn_timeout, self._read_timeout)
                )
                resp.raise_for_status()
                return resp.json()
            except RequestException as e:
                raise convert_requests_exception(e)

    def sync(self, owner, dataset):
        """Triggers ingest of streamed records
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :returns: Response object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('sync'):
            try:
                resp = self._session.post(
                    '{}/datasets/{}/{}/sync'.format(
                        self._api_url, owner, dataset),
                    timeout=(self._conn_timeout, self._read_timeout))
                resp.raise_for_status()
                return resp.json()
            except RequestException as e:
                raise convert_requests_exception(e)

    def truncate_stream_records(self, owner, dataset, stream):
        """Truncates records of a stream in a data.world dataset
        :param owner: User or organization ID of the owner of the dataset
        :type owner: str
        :param dataset: Dataset ID
        :type dataset: str
        :param stream: Stream ID
        :type stream: str
        :returns: Response object
        :rtype: object
        :raises ApiError: Failure invoking data.world API
        """
        with metrics.http_request_timer('truncate_stream_records'):
            try:
                resp = self._session.delete(
                    '{}/streams/{}/{}/{}/records'.format(self._api_url, owner,
                                                         dataset, stream),
                    timeout=(self._conn_timeout, self._read_timeout)
                )
                resp.raise_for_status()
                return resp.json()
            except RequestException as e:
                raise convert_requests_exception(e)

class BackoffAdapter(BaseAdapter):
    def __init__(self, delegate):
        """Requests adapter for retrying throttled requests (HTTP 429)
        :param delegate: Adapter to delegate final request processing to
        :type delegate: requests.adapters.BaseAdapter
        """
        self._delegate = delegate
        super(BackoffAdapter, self).__init__()

    @backoff.on_predicate(backoff.expo,
                          predicate=lambda r: r.status_code == 429,
                          max_tries=lambda: MAX_TRIES)
    def send(self, request, **kwargs):
        resp = self._delegate.send(request, **kwargs)
        if (resp.status_code == 429 and
                resp.headers.get('Retry-After')):
            sleep(int(resp.headers.get('Retry-After')))

        return resp

    def close(self):
        self._delegate.close()
